## Ключевое слово volatile

При создании многопоточных приложений мы можем столкнуться с двумя серьезными проблемами.

**Во-первых, в процессе работы многопоточного приложения разные потоки могут кэшировать значения переменных**

Возможна ситуация, когда один поток изменил значение переменной, а второй не увидел этого изменения, потому что работал со своей, кэшированной копией переменной.

Естественно, последствия могут быть серьезными. Представь, что это не просто какая-то «переменная», а, например, баланс твоей банковской карты, который вдруг начал рандомно скакать туда-сюда :) Не очень приятно, да?

**Во-вторых, в Java операции чтения и записи полей всех типов, кроме `long` и `double`, являются атомарными.**

## Что такое атомарность? 

Ну, например, если ты в одном потоке меняешь значение переменной `int`, а в другом потоке читаешь значение этой переменной, ты получишь либо ее старое значение, либо новое — то, которое получилось после изменения в потоке 1. Никаких «промежуточных вариантов» там появиться не может.

Однако с `long` и `double` это не работает. Почему?

Из-за кроссплатформенности.

Принцип Java — «написано однажды — работает везде»? Это и есть кроссплатформенность. То есть Java-приложение запускается на абсолютно разных платформах. Например, на операционных системах Windows, разных вариантах Linux или MacOS, и везде это приложение будет стабильно работать. 

`long` и `double` — самые «тяжеловесные» примитивы в Java: они весят по 64 бита. И в некоторых 32-битных платформах просто не реализована атомарность чтения и записи 64-битных переменных. Такие переменные читаются и записываются в две операции. Сначала в переменную записываются первые 32 бита, потом еще 32.

Соответственно, в этих случаях может возникнуть проблема. Один поток записывает какое-то 64-битное значение в переменную `Х`, и делает он это «в два захода». В то же время второй поток пытается прочитать значение этой переменной, причем делает это как раз посередине, когда первые 32 бита уже записаны, а вторые — еще нет. В результате он читает промежуточное, некорректное значение, и получается ошибка. 

Например, если на такой платформе мы попытаемся записать в переменную число —

9223372036854775809

— оно будет занимать 64 бита. В двоичной форме оно будет выглядеть так:

1000000000000000000000000000000000000000000000000000000000000001

Первый поток начнет запись этого числа в переменную, и сначала запишет первые 32 бита:

10000000000000000000000000000000

а потом вторые 32:

0000000000000000000000000000001

И в этот промежуток может вклиниться второй поток, и прочитать промежуточное значение переменной — 10000000000000000000000000000000, первые 32 бита, которые уже были записаны.

В десятичной системе это число равняется 2147483648. 

То есть мы всего лишь хотели записать число 9223372036854775809 в переменную, но из-за того, что эта операция на некоторых платформах является не атомарной, у нас из ниоткуда возникло «левое», ненужное нам число 2147483648, и неизвестно как оно повлияет на работу программы. Второй поток просто прочитал значение переменной до того, как оно окончательно записалось, то есть первые 32 бита он увидел, а вторые 32 бита — нет.

Эти проблемы, конечно, возникли не вчера, и в Java они решаются с помощью всего одного ключевого слова — `volatile`.

Если мы объявляем в нашей программе какую-то переменную, со словом volatile…

```Java
public class Main {

   public volatile long x = 2222222222222222222L;

   public static void main(String[] args) {

   }
}
```

…это означает, что:

1. Она всегда будет атомарно читаться и записываться. Даже если это 64-битные double или long.
2. Java-машина не будет помещать ее в кэш. Так что ситуация, когда 10 потоков работают со своими локальными копиями исключена.