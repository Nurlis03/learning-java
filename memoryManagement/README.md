![Alt text](https://github.com/Nurlis03/learning-java/blob/main/memoryManagement/memory_structure.png)

Память делится на две части: **стек**, **куча**.

## Стек (Stack)

Стековая память отвечает за хранение ссылок на объекты кучи и за хранение типов значений (также известных в Java как примитивные типы), которые содержат само значение, а не ссылку на объект из кучи.

## Куча (Heap)

Эта область памяти в котором содержатся
фактические объекты, на которые ссылаются переменные из стека.

``` 
StringBuilder builder = new StringBuilder();
```

Ключевое слово **new** несет ответственность за обеспечение того, достаточно ли свободного места на куче, создавая объект типа **StringBuilder** в памяти и обращаясь к нему через «builder» ссылки, которая попадает в стек

## Типы ссылок
Java использует разные типы ссылок: **сильные, слабые, мягкие и фантомные ссылки**.

Разница между типами ссылок заключается в том, что объекты в куче, на которые они ссылаются, имеют право на сборку мусора по различным критериям.

### 1. Сильная ссылка

Это самые популярные ссылочные типы, к которым мы все привыкли. В приведенном выше примере со StringBuilder мы фактически храним сильную ссылку на объект из кучи. 

Объект в куче не удаляется сборщиком мусора, пока на него указывает сильная ссылка или если он явно доступен через цепочку сильных ссылок.

### 2. Слабая ссылка
Попросту говоря, слабая ссылка на объект из кучи, скорее всего, не сохранится после следующего процесса сборки мусора. Слабая ссылка создается следующим образом:

```
WeakReference<StringBuilder> reference = new WeakReference<>(new StringBuilder());
```

Слабые ссылки используется для кеширования.

### 3. Мягкая ссылка

Эти типы ссылок используются для более чувствительных к памяти сценариев, поскольку они будут собираться сборщиком мусора только тогда, когда вашему приложению не хватает памяти.

Java гарантирует, что все объекты, на которые имеются мягкие ссылки, будут очищены до того, как будет выдано исключение **OutOfMemoryError**.

В документации Javadocs говорится, что «все мягкие ссылки на мягко достижимые объекты гарантированно очищены до того, как виртуальная машина выдаст **OutOfMemoryError**».

```
SoftReference<StringBuilder> reference = new SoftReference<>(new StringBuilder());
```

### 4. Фантомные ссылки
Используется для планирования посмертных действий по очистке, поскольку мы точно знаем, что объекты больше не живы. Используется только с очередью ссылок, поскольку .get()метод таких ссылок всегда будет возвращаться null. Эти типы ссылок считаются предпочтительными для **финализаторов**.

## Ссылки на String

Ссылки на тип String в Java обрабатываются немного по- другому. Строки неизменяемы, что означает, что каждый раз, когда вы делаете что-то со строкой, в куче фактически создается другой объект. Для строк Java управляет пулом строк в памяти. Это означает, что Java сохраняет и повторно использует строки, когда это возможно. В основном это верно для строковых литералов. Например: 

```
String localPrefix = "297"; //1
String prefix = "297";      //2

if (prefix == localPrefix)
{
    System.out.println("Strings are equal" );
}
else
{
    System.out.println("Strings are different");
}Строка  localPrefix  =  «297» ; // 1
```

При запуске этот код распечатывает следующее:

```
Strings are equal
```

Следовательно, оказывается, что две ссылки типа String на одинаковые строковые литералы фактически указывают на одни и те же объекты в куче. Однако это не действует для вычисляемых строк. Предположим, что у нас есть следующее изменение в строке // 1 приведенного выше кода.

```
String localPrefix = new Integer(297).toString(); //1

```
Вывод:
```
String are different
```

В этом случае мы фактически видим, что у нас есть два разных объекта в куче. Если учесть, что вычисляемая строка будет использоваться довольно часто, мы можем заставить JVM добавить ее в пул строк, добавив .intern()метод в конец вычисляемой строки:

```
String localPrefix = new Integer(297).toString().intern(); //1
```

При добавлении вышеуказанного изменения создается следующий результат:

```
Строки равны
```